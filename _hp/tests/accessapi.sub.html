<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTPS Upgrade tests</title>
    <script src="/_hp/resources/testharness.js"></script>
    <script src="/_hp/resources/testharnessreport.js"></script>
    <script src="/_hp/resources/store_results.sub.js"></script>
</head>


<body>

</body>
<script>
    function test_feature_availability(test, src) {
    let frame = document.createElement('iframe');
    frame.src = src;
    function expectFeatureAvailable(evt) {
        if (evt.source === frame.contentWindow &&
            evt.data.type === 'availability-result') {
                test.report_outcome({"enabled": evt.data.enabled});
                assert_equals(null, null);
            document.body.removeChild(frame);
            test.done();
        }
    }
    const promise = new Promise((resolve) => {
        window.addEventListener('message', resolve);
    }).then(expectFeatureAvailable);
    document.body.appendChild(frame);
    return promise;
}


    async function simple_apiaccess_test({ url, response_id, message }) {
        // console.log(url, response_id, message);
        var final_url = url + response_id;
        promise_test(() => {
            return navigator.getBattery().then(function (data) {
                console.log(data);
            });
        }, message);
        async_test(t => {
        test_feature_availability(t, final_url);
      },message);

    }


    // TODO: add other more advanced tests?, double framing, object/embed, ..., sandboxed frame, service workers, ...
    var test_declarations = [simple_apiaccess_test];


    for (var test of test_declarations) {
        // Run all tests for same-origin, same-site, and cross-site
        // TODO: maybe put in a helper func as this is necessary for many tests?
        const path = '/_hp/server/responses.py?feature_group=accessapi&resp_id=';
        // TODO: use both http and https? what about mixed-content?, ...
        // Issue with HTTP for other origins
        const same_org_u = [`${document.location.origin}${path}`, "same-origin"];
        const same_site_u = [`https://{{domains[sub]}}:{{ports[h2][0]}}${path}`, "same-site"];
        const cross_site_u = [`https://{{hosts[alt][]}}:{{ports[h2][0]}}${path}`, "cross-site"];
        // TODO: decide which responses to run on, ...
        // From start_id to end_id (provided by  the testrunner via query parameters &start_id=<id>&end_id=<id>)
        // TODO: put in helper script as it should be the same for all feature groups (also add the browser_id)
        // TODO: Load tests for a specific test group label?! 2, 3 is "XFO"
        for (var response_id of [2, 3]) {
            // for (var [u, site] of [same_org_u, same_site_u, cross_site_u]) {
            for (var [u, site] of [same_org_u, same_site_u, cross_site_u]) {
                test({ url: u, response_id: response_id, message: `${test.name}|${site}|${response_id}` });
            }
        }
    }


</script>

</html>