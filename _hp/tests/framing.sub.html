<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Framing Tests</title>
  <script src="/_hp/resources/testharness.js"></script>
  <script src="/_hp/resources/testharnessreport.js"></script>
  <script src="/_hp/resources/store_results.sub.js"></script>
</head>

<body>

</body>


<script>
var count = 0;
function simple_framing_test({ url, response_id, message }) {
    console.log(url, response_id, message);
    async_test(t => {
      t.set_test_info(url, 'direct');
      //const i = document.createElement("iframe");
      //const i = document.createElement("object");
      const i = document.createElement("embed");
      
      count = count + 1;
      i.id = count;
      i.src = url + response_id + `&count=${i.id}`;
      // for object
      i.data = url + response_id + `&count=${i.id}`;
  
      // Wait for 90% of test_timeout; then report that no message was received!
      let timer = t.step_timeout(() => {
        t.report_outcome({"message": null});
        t.done();
      }, 0.9 * test_timeout);

      // Report that a message was received
      waitForMessageFrom(i, t).then(t.step_func_done(e => {
        clearTimeout(timer);
        t.report_outcome({"message": e.data});
      }));
  
      document.body.append(i);
      t.add_cleanup(() => i.remove());
    }, message);
  }
  
  function waitForMessageFrom(frame, test) {
    return new Promise(resolve => {
      window.addEventListener("message", test.step_func(e => {
        if (e.data == frame.id) {
          resolve(e);
        }
      }));
    });
  }
  
  // TODO: add other more advanced tests?, double framing, object/embed, ..., sandboxed frame, service workers, ...
  // We have the following parameters: dom element: iframe/object/embed
  // We have 
  var test_declarations = [simple_framing_test];


for (var test of test_declarations) {
  // Run all tests for origin relations and similar!
  const origins = get_test_origins();
  const path = '/_hp/server/responses.py?feature_group=framing&resp_id=';
  // Test self-driving tests:
  let urlParams = new URLSearchParams(decodeURIComponent(window.location.search));
  const start_id = parseInt(urlParams.get("start_id"), 10) || 0;
  const chunk_size = parseInt(urlParams.get("chunk_size"), 10) || 1;
  const end_id = parseInt(urlParams.get("end_id"), 10) || 1;

  // Currently for testing get resp_ids via the label endpoint!
  // Later: From start_id to end_id (provided by  the testrunner via query parameters &start_id=<id>&end_id=<id>&chunk_size=<chunk_size>)
  // TODO: iterate over the fixed ids instead of fetching them dynamically
  //for (var response_id=start_id; response_id < Math.min(end_id, start_id + chunk_size); i++){
  fetch(`${location.origin}/_hp/server/get_resp_ids.py?label=CSP-FA`).then(resp => resp.json()).then(ids => {
    for (var response_id of ids){
      for (var origin of origins) {
        test({url: `${origin}${path}`, response_id: response_id, message: `${test.name}|${origin}|${response_id}`});
      }
    }
  });
}


// TODO: try the polling idea: poll until either access possible or SOP exception
// Then log access possible/not possible + number of frames in the document? (Does that work for object, embed?)
// Problem how to use it for nested cases?
// Maybe only do the polling in the parent of the final response? other frames just pass the results as postMessages up?


// Alternative idea without postMessages: wait for "load" and access number of frames or similar?
// Iframes should always fire a load event
// Sadly this is broken in Firefox for CSP-FA https://bugzilla.mozilla.org/show_bug.cgi?id=1552504 and other network errors: https://bugzilla.mozilla.org/show_bug.cgi?id=929899
// For XFO this would work though
// Alternative option: https://github.com/web-platform-tests/wpt/commit/eef4b22afc49a1fac410559d6101e8fda942ce31
if (false) {
i.onload = t.step_func_done(() => {
  //assert_equals(i.contentDocument, null);
  t.report_outcome({"frames.length": i.contentWindow.frames.length, "res": format_value([null, undefined, "null", "undefined", -0])});
  assert_equals(null, null);
});
}


</script>
</html>