<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Framing Tests</title>
  <script src="/_hp/resources/testharness.sub.js"></script>
  <script src="/_hp/resources/store_results.sub.js"></script>
</head>

<body>

</body>


<script>
  let urlParams = new URLSearchParams(decodeURIComponent(window.location.search));
  let resp_type = urlParams.get("resp_type") || "debug";
  var count = 0;
  function framing_test(element, sandbox, test_info, url, origin, response_id) {
    /*
    url: str, URL to be tested (next in the framing chain)
    origin: str, Origin of the URL to be tested
    response_id: int, ID of the response element (final response of the chain)
    element: str, iframe/object/embed
    sandbox: bool whether to add the sandbox attribute to the next frame
    test_info: str, additional information about the test (direct, sandbox, nested (A->B->A->A))
    */
    test_name = `framing_${element}|${sandbox}|${test_info}|${origin}|${response_id}`;
    //console.log(url, response_id, test_name);
    if (test_info == "direct") {
      async_test(t => {
        t.set_test_info(url, test_info);
        const i = document.createElement(element);
        count = count + 1;
        i.id = count;
        let origin = location.origin;
        let final_url = url + response_id + `&count=${i.id}&nest=0&origin=${origin}&element=${element}&resp=1`
        i.data = final_url; // Object
        i.src = final_url; // Embed + IFrame
        // Wait for 90% of test_timeout; then report that no message was received!
        let timer = t.step_timeout(() => {
          t.report_outcome("message timeout");
          t.done();
        }, 0.9 * test_timeout);
        // Report that a message was received
        waitForMessageFrom(i, t).then(t.step_func_done(e => {
          clearTimeout(timer);
          t.report_outcome(e.data.message);
        }));
        // Cleanup function (remove the frame after the test)
        t.add_cleanup(() => i.remove());
        // Start the test
        document.body.append(i);
      }, test_name);
    } else {
      nested_test(element, sandbox, url, response_id, element, test_info, test_name);
    }
  }

  // A -> B
  const simple_iframe = framing_test.bind(null, 'iframe', false, "direct");
  const simple_object = framing_test.bind(null, 'object', false, "direct");
  const simple_embed = framing_test.bind(null, 'embed', false, "direct");

  // A -> B (sandboxed) -> A
  const sandboxed_iframe = framing_test.bind(null, 'iframe', true, "sandbox");
  const sandboxed_object = framing_test.bind(null, 'object', true, "sandbox");  // Should not exist?
  const sandboxed_embed = framing_test.bind(null, 'embed', true, "sandbox");  // Should not exist?

  // A -> B -> A -> A to test for the full inclusion chain  (testing A->B->B and A->B->A is left out for performance)
  const nested_iframe = framing_test.bind(null, 'iframe', false, "nested");
  const nested_object = framing_test.bind(null, 'object', false, "nested");
  const nested_embed = framing_test.bind(null, 'embed', false, "nested");

  // 8 (options for B) * 9 (tests) * 2 (responses) = 144 tests?! * 2 as we have two options for A (http/https :// sub.headers.websec.saarland)

  // OPTIONAL: add other more advanced tests? service workers, ...
  let test_declarations;
  if (resp_type === "parsing") {
    test_declarations = [simple_iframe, nested_iframe];
  } else {
    test_declarations = [simple_iframe, simple_object, simple_embed,
      sandboxed_iframe, sandboxed_object, sandboxed_embed,
      nested_iframe, nested_object, nested_embed];
  }

  const path = '/_hp/server/responses.py?feature_group=framing&resp_id=';
  const label = urlParams.get("label") || 'CSP-FA';
  run_tests(test_declarations, path, label);

</script>

</html>