<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Framing Tests</title>
  <script src="/_hp/resources/testharness.js"></script>
  <script src="/_hp/resources/testharnessreport.js"></script>
  <script src="/_hp/resources/store_results.sub.js"></script>
</head>

<body>

</body>


<script>
function simple_framing_test({ url, response_id, message }) {
    console.log(url, response_id, message);
    async_test(t => {
      const i = document.createElement("iframe");
      i.src = url + response_id;
  
      //waitForMessageFrom(i, t).then(t.unreached_func("Frame should not have sent a message."));
      // Iframes should always fire a load event
      // Sadly this is broken in Firefox for CSP-FA https://bugzilla.mozilla.org/show_bug.cgi?id=1552504 and other network errors: https://bugzilla.mozilla.org/show_bug.cgi?id=929899
      // For XFO this would work though
      // Alternative option: https://github.com/web-platform-tests/wpt/commit/eef4b22afc49a1fac410559d6101e8fda942ce31
      i.onload = t.step_func_done(() => {
        //assert_equals(i.contentDocument, null);
        t.report_outcome({"frames.length": i.contentWindow.frames.length, "res": format_value([null, undefined, "null", "undefined", -0])});
        assert_equals(null, null);

      });
      //waitForMessageFrom(i, t).then(t.step_func_done(e => {
      //  assert_equals(e.data, "Loaded");
      //}));
  
      document.body.append(i);
      t.add_cleanup(() => i.remove());
    }, message);
  }
  
  function waitForMessageFrom(frame, test) {
    return new Promise(resolve => {
      window.addEventListener("message", test.step_func(e => {
        console.log(e);
        if (e.source == frame.contentWindow) {
          resolve(e);
        }
      }));
    });
  }
  
  // TODO: add other more advanced tests?, double framing, object/embed, ..., sandboxed frame, service workers, ...
  var test_declarations = [simple_framing_test];


for (var test of test_declarations) {
  // Run all tests for same-origin, same-site, and cross-site
  // TODO: maybe put in a helper func as this is necessary for many tests?
  const path = '/_hp/server/responses.py?feature_group=framing&resp_id=';
  // TODO: use both http and https? what about mixed-content?, ...
	const same_org_u = [`${document.location.origin}${path}`, "same-origin"];
	const same_site_u = [`https://{{domains[sub]}}:{{ports[h2][0]}}${path}`, "same-site"];
	const cross_site_u = [`https://{{hosts[alt][]}}:{{ports[h2][0]}}${path}`, "cross-site"];
	// TODO: decide which responses to run on, ...
  // From start_id to end_id (provided by  the testrunner via query parameters &start_id=<id>&end_id=<id>)
  // TODO: put in helper script as it should be the same for all feature groups (also add the browser_id)
  // TODO: Load tests for a specific test group label?! 2, 3 is "XFO"
  for (var response_id of [2, 3]){
    for (var [u, site] of [same_org_u, same_site_u, cross_site_u]) {
      test({url: u, response_id: response_id, message: `${test.name}|${site}|${response_id}`});
    }
  }
}


</script>
</html>