<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTPS Upgrade tests</title>
    <script src="/_hp/resources/testharness.sub.js"></script>
    <script src="/_hp/resources/store_results.sub.js"></script>
</head>


<body>

</body>
<script>
    const fetchDataWithTimeout = async (url, timeout) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, { signal: controller.signal, "method": "GET", "mode": "no-cors" });
        clearTimeout(timeoutId); // Clear the timeout since the request was successful
        return response;
    };

    let resp_type = urlParams.get("resp_type") || "debug";
    async function upgrade_test(test_info, url, origin, response_id) {
        test_name = `upgradeHSTS_${test_info}|${origin}|${response_id}`;
        let u = new URL(origin);
        promise_test(async t => {
            t.set_test_info(url, test_info);
            // Reset HSTS after every request/test
            t.add_cleanup(async () => {
                return new Promise((resolve, reject) => {
                    // Use WPT pipes to echo responses we need: https://web-platform-tests.org/writing-tests/server-pipes.html?highlight=status%20code
                    fetch(origin + "/_hp/common/empty.html?pipe=header(strict-transport-security,max-age=0)|status(200)", { mode: "no-cors" }).then(resolve).catch(() => reject(new Error("Cleanup failed")))
                });
            });
            // Visit URL that (might) set HSTS
            // No-CORS request such that we do not have to care about ACAO
            try {
                // The initial fetch should be fast
                let asis_id = urlParams.get("asis_id");
                let r;
                if (asis_id) {
                    r = await fetchDataWithTimeout("https://" + u.host + "/_hp/asis/" + asis_id, test_timeout/5);
                } else {
                    r = await fetchDataWithTimeout(url + response_id, test_timeout/5);
                }
                assert_equals(r.bodyUsed, false, "Initial request succeeded");
                // Visit http://(sub.)host to check for HSTS/redirect
                let test_url;
                if (test_info == "subdomain") {
                    test_url = "http://sub." + u.host + "/_hp/common/empty.html";
                } else {
                    test_url = "http://" + u.host + "/_hp/common/empty.html";
                }
                // CORS request such that we can access r.redirected
                r = await fetch(test_url, { "method": "GET" });
                //console.log(r);
                t.report_outcome({ "response.redirected": r.redirected });
                assert_equals(r.bodyUsed, false, "Second request finished");
            } catch (e) {
                if (e.name === 'AbortError') {
                    t.report_outcome("Fetch timed out");
                } else {
                    // Catch errors and report them (e.g., \x00 in header will usually result in a failed fetch!)
                    t.report_outcome(e.toString());
                }
            }

        }, test_name);
    }

    const simple_upgrade_test = upgrade_test.bind(null, "direct");
    simple_upgrade_test.element_relation = "direct_direct";
    const subdomain_upgrade_test = upgrade_test.bind(null, "subdomain");
    subdomain_upgrade_test.element_relation = "subdomain_subdomain";


    // Simple upgrade test: Visit URL that sets HSTS, visit http://(sub.)<host of URL> and check for redirect
    // OPTIONAL: other tests e.g., caching or clearing related?, double subdomain?    let test_declarations;
    if (resp_type === "parsing") {
        test_declarations = [simple_upgrade_test, subdomain_upgrade_test];
    } else {
        test_declarations = [simple_upgrade_test, subdomain_upgrade_test];
    }
    const path = '/_hp/server/responses.py?feature_group=hsts&nest=0&resp=1&resp_id=';
    const label = 'HSTS';
    // Use hosts[alt][] to test a different origin as the one we are on (not poison ourselves)
    if (location.protocol == "http:") {
        run_tests(test_declarations, path, label, ["http://sub.{{host}}", "https://sub.{{host}}"]);
    } else {
        // Due to mixed content blocking we cannot fetch http on https and our tests would fail
        // These tests only are meaningful if we visit the test site on http (alternatively we would need to use passive content/non-fetch)
        alert("Only works from HTTP!");
    }

</script>

</html>