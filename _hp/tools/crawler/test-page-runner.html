<!DOCTYPE html>
<html>

<head>
	<title>Test Page Runner: open one Test URL at a time from a list of Test URLs.</title>
</head>

<body>
	<script>
		// Insert URLs and timeout dynamically
		let urls = $$$URLS$$$;
		let timeout = $$$TIMEOUT$$$;
		let counter = 0;
		let openWindow;
		let timeoutId;
		let urlParams = new URLSearchParams(decodeURIComponent(window.location.search));
		let browser_id = urlParams.get('browser_id') || 1;
		let run_id = urlParams.get('run_id') || "unknown";

		function closeCurrentWindow() {
			if (openWindow) {
				openWindow.close();
			}
		}

		function openNextWindow() {
			closeCurrentWindow();

			if (counter < urls.length) {
				// interpreted as: top=min,left=min,width=min,height=min
				let url = urls[counter];
				url = url.replace(/browser_id=\d+/, `browser_id=${browser_id}`);
				url_timeout = Math.max(parseInt(url.match(/timeout=(\d+)/)[1], 10) * 1000 + 2000, timeout);
				openWindow = window.open(url, "_blank", "top=0,left=0,width=100,height=100");
				counter++;
				// Open the next test after the TIMEOUT
				timeoutId = setTimeout(function () {
					openNextWindow();
				}, url_timeout);

			} else {
				console.log("Finished!");
				// Append a "finished" div which we can await for in Selenium/Playwright based tests
				d = document.createElement("div");
				d.id = "finished";
				document.body.style.backgroundColor = "green";
				document.body.appendChild(d);
				
				// Try to stop the page runner
				fetch(`${location.origin}/_hp/server/notify_runner_clients.py?run_id=${run_id}`);

			}
		}

		function handleMessage(event) {
			// If the test is finished, clear the timeout and directly start the next test
			if (event.data === 'finished') {
				clearTimeout(timeoutId);
				openNextWindow();
			}
		}
		window.addEventListener('message', handleMessage);

		// Open the first window
		openNextWindow();


	</script>
</body>

</html>